upstream frps_upstream {
    server frps:8080;
}

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

init_by_lua_block {
    dispatch_node = function()
        local redis = require "resty.redis"
        local red = redis:new()
        
        red:set_timeouts(100, 100, 100) -- 100 millisec
        
        local ok, err = red:connect("redis", 6379)
        
        if not ok then
            ngx.log(ngx.ERR, "failed to connect: ", err)
            return
        end
        
        red:select(0)
        
        local origin_host = ngx.var.host
        local start_index, end_index = string.find(origin_host, ".", 1, true)
        local host_domain = string.sub(origin_host, 1, start_index - 1)
        local root_domain = string.sub(origin_host, start_index)
        
        local res, err = red:lmove(host_domain, host_domain, "RIGHT", "LEFT")
        if not res then
            ngx.log(ngx.ERR, "failed to get node from ", origin_host, ": ", err)
            return
        end
        
        if res == ngx.null then
            ngx.log(ngx.ERR, "node from ", origin_host, " not found.")
            return
        end
        
        ngx.log(ngx.DEBUG, "Found node from ", origin_host, ": ", res)

        ngx.var.node_domain = res .. root_domain
        end
    }

server {
    listen 80;
    server_name *.yourdomain.ai;

    # Used by lua for connecting redis
    resolver 127.0.0.11;

    access_log /logs/nginx/ai_access.log main;
    error_log /logs/nginx/ai_error.log error;

    lua_need_request_body on;

    location = /favicon.ico {return 200 "";}

    set $node_domain $http_host;

    location / {
        access_by_lua_block {
            dispatch_node()
        }

        proxy_pass http://frps_upstream;
        proxy_set_header Host $node_domain;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }

    location /v1/chat/completions {
        access_log  /logs/nginx/access_tokens.log log_req_resp;
        set $resp_header_user "";
        header_filter_by_lua_block{
            local rh = ngx.resp.get_headers();
            for k, v in pairs(rh) do
                if k == "user" then
                    ngx.var.resp_header_user = ngx.var.resp_header_user .. v;
                end
            end
        }

        set $resp_body "";
        body_filter_by_lua '
            local resp_body = ngx.arg[1]

            if string.find(resp_body, "total_tokens") then
                ngx.ctx.buffered = (ngx.ctx.buffered or "") .. resp_body
            end
            if ngx.arg[2] then
                ngx.var.resp_body = ngx.ctx.buffered
            end
        ';

        access_by_lua_block {
            dispatch_node()
        }

        proxy_max_temp_file_size 0;
        proxy_pass http://frps_upstream;
        proxy_set_header Host $node_domain;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }

    location /config_pub {
        access_by_lua_block {
            dispatch_node()
        }

        proxy_set_header Host $node_domain;
        proxy_pass http://frps_upstream;
        add_header 'Access-Control-Allow-Origin' *;
        add_header 'Access-Control-Allow-Credentials' 'true';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'Origin, X-Requested-With, Content-Type, Accept, Authorization';
    }
}
